{{>preamble}}
#pragma once

#include "basejob.hpp"
{{#imports}}
#include {{_}}{{/imports}}

namespace Kazv {
{{#operations.operation}}

/*!{{>docCommentSummary}}{{#description}}
 * {{_}}{{/description}}
 */
class {{camelCaseOperationId}}Job : public BaseJob {
public:
{{#models}}
  // Inner data structures
  {{#model}}

    {{>docCommentShort}}
    struct {{name}}{{#parents?}} :
      {{#parents}}{{name}}{{>cjoin}}{{/parents}}{{/parents?}}
        {
        {{#vars}}
          {{>docCommentShort}}
          {{>maybeOmittableType}} {{nameCamelCase}};
        {{/vars}}
        {{#propertyMap}}
          {{>docCommentShort}}
          {{>maybeOmittableType}} {{nameCamelCase}};
        {{/propertyMap}}
        };
  {{/model}}

{{/models}}

// Construction/destruction

{{#allParams?}}
  /*!{{>docCommentSummary}}
  {{#allParams}}
    * \param {{nameCamelCase}}{{#description}}
    *   {{_}}{{/description}}{{#_join}}
    * {{/_join}}
  {{/allParams}}
    */
  {{/allParams?}}{{^allParams?}}
        {{#summary}}
    /// {{summary}}
        {{/summary}}
    {{/allParams?}}
    explicit {{camelCaseOperationId}}Job(std::string serverUrl
    {{^skipAuth}}, std::string _accessToken{{/skipAuth}}
      {{#allParams?}},{{/allParams?}}
        {{#allParams}}{{>joinedParamDecl}}{{/allParams}});
    {{^hasBody?}}

    {{/hasBody?}}
    {{#responses}}{{#normalResponse?}}{{#allProperties?}}

    // Result properties
        {{#headers}}
/*
    {{>nonInlineResponseSignature}}
    {
        return reply()->rawHeader("{{baseName}}");
    }
*/        {{/headers}}
        {{#inlineResponse}}

    {{>docCommentShort}}
    static {{dataType.name}} {{paramName}}(Response r)
    {
    return
    {{#producesNonJson?}}
      std::get<Bytes>(r.body)
    {{/producesNonJson?}}
    {{^producesNonJson?}}
      std::move(jsonBody(r).get()).get<{{dataType.name}}>()
    {{/producesNonJson?}}
    ;
    }
        {{/inlineResponse}}
        {{#properties}}

    {{!there's nothing in #properties if the response is inline}}
    {{>nonInlineResponseSignature}};
        {{/properties}}
    {{/allProperties?}}{{/normalResponse?}}{{/responses}}

    static BaseJob::Query buildQuery(
    {{#queryParams}}{{>joinedParamDef}}{{/queryParams}});

      static BaseJob::Body buildBody({{#allParams}}{{>joinedParamDef}}{{/allParams}});

        static bool success(Response r);
        {{#producesNonJson?}}
          static const immer::array<std::string> expectedContentTypes;
        {{/producesNonJson?}}
      };

      } {{! namespace Kazv}}
      namespace nlohmann
      {
      using namespace Kazv;
    {{#models.model}}
      template<>
      struct adl_serializer<{{qualifiedName}}> {
{{#in?}}
  static void to_json(json& jo, const {{qualifiedName}} &pod)
  {
  {{#parents}}{{!assume no more one parent}}
    jo = static_cast<const {{name}} &>(pod);
    //nlohmann::to_json(jo, static_cast<const {{name}} &>(pod));
  {{/parents}}
  {{#propertyMap}}
    addPropertyMapToJson(jo, pod.{{nameCamelCase}});
  {{/propertyMap}}
  {{#vars}}
    {{#required?}}jo["{{baseName}}"s] = pod.{{nameCamelCase}};{{/required?}}
    {{^required?}}addToJsonIfNeeded(jo, "{{baseName}}"s, pod.{{nameCamelCase}});{{/required?}}
  {{/vars}}
  }
{{/in?}}
{{#out?}}
  static void from_json(const json &jo, {{qualifiedName}}& result)
  {
  {{#parents}}
    static_cast<{{name}} &{{!of the parent!}}>(result) = jo;
    //nlohmann::from_json(jo, static_cast<const {{name}} &{{!of the parent!}}>(result));
  {{/parents}}
  {{#vars}}
    result.{{nameCamelCase}} = jo.at("{{baseName}}"s);
  {{/vars}}
  {{#propertyMap}}
    result.{{nameCamelCase}} = jo;
  {{/propertyMap}}
  }
{{/out?}}
};
    {{/models.model}}
    }

    namespace Kazv
    {
{{/operations.operation}}

} // namespace Kazv
