{{>preamble}}
#pragma once

#include "basejob.hpp"
{{#imports}}
#include {{_}}{{/imports}}

namespace Kazv {
{{#operations.operation}}

/*!{{>docCommentSummary}}{{#description}}
 * {{_}}{{/description}}
 */
class {{camelCaseOperationId}}Job : public BaseJob {
public:
{{#models}}
  // Inner data structures
  {{#model}}

    {{>docCommentShort}}
    struct {{name}}{{#parents?}} :
      {{#parents}}{{name}}{{>cjoin}}{{/parents}}{{/parents?}}
        {
        {{#vars}}
          {{>docCommentShort}}
          {{>maybeOmittableType}} {{nameCamelCase}};
        {{/vars}}
        {{#propertyMap}}
          {{>docCommentShort}}
          {{>maybeOmittableType}} {{nameCamelCase}};
        {{/propertyMap}}
        };
  {{/model}}

{{/models}}

// Construction/destruction

{{#allParams?}}
  /*!{{>docCommentSummary}}
  {{#allParams}}
    * \param {{nameCamelCase}}{{#description}}
    *   {{_}}{{/description}}{{#_join}}
    * {{/_join}}
  {{/allParams}}
    */
  {{/allParams?}}{{^allParams?}}
        {{#summary}}
    /// {{summary}}
        {{/summary}}
    {{/allParams?}}
    explicit {{camelCaseOperationId}}Job(std::string serverUrl{{#allParams?}},{{/allParams?}}
        {{#allParams}}{{>joinedParamDecl}}{{/allParams}});
    {{^hasBody?}}

    {{/hasBody?}}
    {{#responses}}{{#normalResponse?}}{{#allProperties?}}

    // Result properties
        {{#headers}}
/*
    {{>nonInlineResponseSignature}}
    {
        return reply()->rawHeader("{{baseName}}");
    }
*/        {{/headers}}
        {{#inlineResponse}}

    {{>docCommentShort}}
    static {{dataType.name}} {{paramName}}(Response r)
    {
    return
    {{#producesNonJson?}}
      r
    {{/producesNonJson?}}
    {{^producesNonJson?}}
      std::move(jsonBody(r).get()).get<{{dataType.name}}>()
    {{/producesNonJson?}}
    ;
    }
        {{/inlineResponse}}
        {{#properties}}

    {{!there's nothing in #properties if the response is inline}}
    {{>nonInlineResponseSignature}}
    {
    return jsonBody(r).get()
    .contains("{{baseName}}"s) ?
    jsonBody(r).get()["{{baseName}}"s]
    .get<{{dataType.name}}>() : {{defaultValue}};
    }
        {{/properties}}
    {{/allProperties?}}{{/normalResponse?}}{{/responses}}
};
    {{#models.model}}

{{#in?}}
  inline void to_json(json& jo, const {{qualifiedName}} &pod)
  {
  {{#parents}}{{!assume no more one parent}}
    nlohmann::to_json(jo, static_cast<const {{name}} &>(pod));
  {{/parents}}
  {{#propertyMap}}
    addPropertyMapToJson(jo, pod.{{nameCamelCase}});
  {{/propertyMap}}
  {{#vars}}
    {{#required?}}jo["{{baseName}}"s] = pod.{{nameCamelCase}};{{/required?}}
    {{^required?}}addToJsonIfNeeded(jo, "{{baseName}}"s, pod.{{nameCamelCase}});{{/required?}}
  {{/vars}}
  }
{{/in?}}
{{#out?}}
  inline void from_json({{>maybeCrefJsonObject}} jo, {{qualifiedName}}& result)
  {
  {{#parents}}
    nlohmann::from_json(static_cast<const {{name}} &{{!of the parent!}}>(result), result);
  {{/parents}}
  {{#vars}}
    result.{{nameCamelCase}} = jo.at("{{baseName}}"s);
  {{/vars}}
  {{#propertyMap}}
    from_json(jo, result.{{nameCamelCase}});
  {{/propertyMap}}
  }
{{/out?}}

    {{/models.model}}
{{/operations.operation}}

} // namespace Kazv
