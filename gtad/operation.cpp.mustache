{{>preamble}}
#include "{{filenameBase}}.hpp"

namespace Kazv
{
{{#operations}}{{#operation}}
  {{#queryParams?}}

BaseJob::Query {{camelCaseOperationId}}Job::buildQuery(
{{#queryParams}}{{>joinedParamDef}}{{/queryParams}})
{
BaseJob::Query _q;
{{#queryParams}}
  {{#required?}}
    addToQuery(_q, "{{baseName}}"s, {{paramName}});
  {{/required?}}
  {{^required?}}
    addToQueryIfNeeded(_q, "{{baseName}}"s, {{paramName}});
  {{/required?}}
{{/queryParams}}
return _q;
}
    {{/queryParams?}}

    BaseJob::Body {{camelCaseOperationId}}Job::buildBody({{#allParams}}{{>joinedParamDef}}{{/allParams}})
      {
      // ignore unused param
      {{#allParams}}(void)({{paramName}});{{/allParams}}
      {{#inlineBody}}{{^propertyMap}}{{^bodyParams?}}
        return {{#consumesNonJson?}}BaseJob::BytesBody({{nameCamelCase}}){{/consumesNonJson?}}
          {{^consumesNonJson?}}BaseJob::JsonBody({{nameCamelCase}}){{/consumesNonJson?}};
          {{/bodyParams?}}{{/propertyMap}}{{/inlineBody}}
      {{#bodyParams?}}
        json _data
        {{#inlineBody}}
          ({{paramName}})
        {{/inlineBody}};
        {{#propertyMap}}
          addPropertyMapToJson(_data, {{nameCamelCase}});
        {{/propertyMap}}
        {{#bodyParams}}
          {{#required?}}
            _data["{{baseName}}"s] = {{paramName}};
          {{/required?}}
          {{^required?}}
            addToJsonIfNeeded(_data, "{{baseName}}"s, {{paramName}});
          {{/required?}}
        {{/bodyParams}}
        return BaseJob::JsonBody(_data);
        {{/bodyParams?}}
        {{^bodyParams?}}
          {{^inlineBody}}
            {{^propertyMap?}}
              return BaseJob::EmptyBody{};
        {{/propertyMap?}}
        {{/inlineBody}}
        {{/bodyParams?}}

      };

{{camelCaseOperationId}}Job::{{camelCaseOperationId}}Job(
        std::string serverUrl
        {{^skipAuth}}, std::string _accessToken{{/skipAuth}}
        {{#allParams?}},{{/allParams?}}
        {{#allParams}}{{>joinedParamDef}}{{/allParams}})
      : BaseJob(std::move(serverUrl),
          std::string("{{basePathWithoutHost}}"){{#pathParts}} + {{_}}{{/pathParts}},
          {{#_toupper}}{{httpMethod}}{{/_toupper}},
          {{^skipAuth}}_accessToken{{/skipAuth}}{{#skipAuth}} {} {{/skipAuth}},
          ReturnType::{{^producesNonJson?}}Json{{/producesNonJson?}}{{#producesNonJson?}}Byte{{/producesNonJson?}},
            buildBody({{#allParams}}{{paramName}}{{>cjoin}}{{/allParams}})
      {{#queryParams?}}, buildQuery({{#queryParams}}{{paramName}}{{>cjoin}}{{/queryParams}}){{/queryParams?}})
        {
        {{#headerParams}}
          //setRequestHeader("{{baseName}}", {{paramName}}.toLatin1());
        {{/headerParams}}
        {{#producesNonJson?}}
          //setExpectedContentTypes({ {{#produces}}"{{_}}"{{>cjoin}}{{/produces}} });
        {{/producesNonJson?}}
        {{^producesNonJson?}}{{#responses}}{{#normalResponse?}}{{#properties}}{{#required?}}
          //addExpectedKey("{{baseName}}");
        {{/required?}}{{/properties}}{{/normalResponse?}}{{/responses
        }}{{/producesNonJson?}}
        }

        {{#responses}}{{#normalResponse?}}
                {{#properties}}

    {{!there's nothing in #properties if the response is inline}}
    {{>qualifiedMaybeOmittableType}} {{camelCaseOperationId}}Job::{{paramName}}(Response r)
    {
    if (jsonBody(r).get()
    .contains("{{baseName}}"s)) {
    return
    jsonBody(r).get()["{{baseName}}"s]
    /*.get<{{dataType.name}}>()*/;}
    else { return {{>maybeOmittableType}}( {{defaultValue}} );}
    }
        {{/properties}}{{/normalResponse?}}{{/responses}}

{{/operation}}{{/operations}}
}
